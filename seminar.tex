\documentclass{beamer}
\usepackage{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{stmaryrd}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{proof}
\usepackage{bussproofs}
\usepackage{listings}
\usepackage{amsmath}

\usetheme{Copenhagen}
\usefonttheme{professionalfonts}
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{headline}{}

\definecolor{delimiterColor}{HTML}{B65E47}
\definecolor{numberColor}{HTML}{FF0000}
\definecolor{commentColor}{HTML}{008000}
\definecolor{keyColor}{HTML}{002BFF}

\lstdefinelanguage{maude}
{
	breaklines=true,
	extendedchars=true,
	tabsize=2,
	frame=none,
	columns=fullflexible,
	showtabs=false,
	showstringspaces=false,
	showspaces=false,
	showstringspaces=false,
	identifierstyle={\ttfamily},
	keywordstyle={\color{keyColor}},
	ndkeywordstyle={\color{keyColor}},
	stringstyle={\color{delimiterColor}},
	commentstyle={\color{commentColor}},
	ndkeywords={Int, Bool, String},
	keywords={in, load, pr, protecting, sort, sorts, op, ops, var, vars,eq, cq, ceq,endfm, fmod, is, mod, endm, load, =, ==, =/=, euler, discreteswitch, nonaccurate, mp, rk4, accurate, init, exp, abs, true, false, nil, ctor, PhysicalEntityStar, PhysicalInteraction, PhysicalEntity, PhysicalEntityPC1, FlowSource, SysMan, effortDyn, flowDyn, Object, Oid, assoc, comm, id, DataCollector, Rat, NzNat, frac, trunc, if, else, class, load, homod, endhom, eof, var, vars, eq, op, ops, pr, inc, protecting, including, ceq, is, tomod, endtom, msg, rl, crl, trew, hfind, hsearch, tsearch, hmc, hrew, time, earliest, such, that, subclass, Prop, omod, sort, subsort, not, endom, fi, msgs, fmod, endfm, hfrew, then, mod, and, or, endm, endtm, in, out, set, trace, exclude, loop, show, using, stepsize, tick, Oid, Nat, Float, Configuration, String, NzNat},
	morecomment={[l]{***}},
	morecomment={[l]{---}},
}
\AtBeginSection[ ]
{
\begin{frame}{Outline}
    \tableofcontents[currentsection, hideallsubsections]
\end{frame}
}
\title{Conditional Rewriting Logic \& Maude}
\author{Niccolò Piazzesi}
\institute{
    Università degli studi di Pisa
}
\titlegraphic{\includegraphics[width=2cm]{img/logo.png}}
\begin{document}

\frame{\titlepage}

\begin{frame}{Outline}
    \tableofcontents[hideallsubsections]
\end{frame}
\section{Introduction and main concepts}
\begin{frame}
    \frametitle{What is a concurrent system?}
    Modelling concurrent system is one of the most studied problems in Computer Science

    \bigskip
    \pause
    Many proposed answers:\begin{itemize}
        \item Petri Nets 
        \item CCS
        \item CSP 
        \item Actors
        \item $\cdots$
    \end{itemize}
\end{frame}
\begin{frame}
    \frametitle{The need for unification}
    \pause
        \begin{block}{External fragmentation}
            Hard to relate different approaches, each with their own concepts, models and issues
        \end{block}
    \pause 
    \begin{block}{Internal fragmentation}
        Sometimes, fragmentation appears also within a specific approach (e.g. how can we unify operational and denotational semantics of CCS?)
    \end{block}
    \pause
    \begin{block}{Concurrency in other areas}
        A related problem is the integration of concurrency with other paradigms ( OO, Functional, ...)
        without using complex \emph{ad hoc} solutions.
    \end{block}
\end{frame}

\begin{frame}
    
    Rewriting logic aim to resolve these issues with a two sides approach
    \pause
    \begin{block}{Computational side}
        Computationally, rewriting logic is a \emph{semantic framework} where many different 
        models and languages can be represented and executed as \textbf{rewrite theories}. 
    \end{block}
    \pause
    \begin{block}{Logical side}
        Rewriting logic  is also a \emph{logical framework}, a model within which 
        many other logics and deduction procedures  can be modeled and reasoned about.        
    \end{block}
\end{frame}
\section{Foundations}
\begin{frame}
    \frametitle{A logic of action}
    The rules of rewriting logic resemble those of equational logic, but the meaning is very different

    \begin{center}
        \textbf{Rewriting logic is a logic to reason about \emph{change} in a concurrent system, \emph{not about equality}}
    \end{center}
\pause 

\bigskip 
Rewriting logic identifies \textbf{concurrent rewriting} with \textbf{deduction}
\end{frame}

\begin{frame}
    \frametitle{Rewrite Theory}
    \begin{center}
        \resizebox{3cm}{!}{$(\Sigma, E, L, R)$}
    \end{center}
    
    \bigskip
    \begin{itemize}
        \pause
        \item $\Sigma$: ranked alphabet of function symbols
        \pause
        \item E: set  of $\Sigma$-equations 
        \pause
        \item L: set of \emph{labels}
        \pause
        \item R: set of pairs $R \subseteq L \times (T_{\Sigma, E}(\mathbf{X})^2)^+$
    \end{itemize}
    
    \pause
    \bigskip
    $T_{\Sigma,E}(\mathbf{X})$ denotes the $\Sigma-algebra$ of equivalence classes of $\Sigma-terms$ with variables in $\mathbf{X}$ modulo the equations E
    
    \medskip
    Elements of R are called \emph{rewrite rules}
\end{frame}
\begin{frame}
    \frametitle{Rewriting rules}
    A rewrite rule 
    \begin{center}
        $(r,([t],[t'])([u_1],[v_1])\cdots([u_k],[v_k]))$
    \end{center}
    is written as 
    $$
    r:[t] \rightarrow [t']\ if\ \underbrace{[u_1]\rightarrow[v_1] \wedge \cdots \wedge [u_k] \rightarrow [v_k] \pause}_{condition\ C}
    $$
    
    \bigskip
    \pause
    If a condition is empty, we have an \emph{unconditional rewrite rule} 
    $$
    r:[t] \rightarrow [t']
    $$
    

    If all the rules are unconditional , we have an \emph{unconditional rewrite theory}
\end{frame}
\begin{frame}

    An example: natural numbers with a nondeterministic choice operator 
    
    \pause
    \begin{itemize}
        \item $\Sigma = \{0,s\_,\_+\_,\_?\_\}$
        \pause
        \item $E = \{N + M = M + N\}$
        \pause
        \item R = 
            \vspace{-5mm}
            \begin{align*}
                &r1: N+0 \rightarrow N \\ 
                &r2: (s\ N) + (s\ M) \rightarrow s\ s\ (N + M) \\ 
                &r3: N ? M \rightarrow N \\ 
                &r4: N ? M \rightarrow M 
            \end{align*}
    \end{itemize}
\end{frame}
\begin{frame}
    \frametitle{Sequent entailment}
    \begin{center}
        \resizebox{3cm}{!}{$\mathcal{R} \vdash [t] \rightarrow [t']$}
    \end{center}

    \pause 
    \vspace{2cm}
    A rewrite theory $\mathcal{R}$ \emph{entails} a \emph{sequent}
    $ [t] \rightarrow [t']$ \emph{iff} $[t] \rightarrow [t']$ can be obtained 
    by finite application of \emph{rules of deduction}.
\end{frame}
\begin{frame}[allowframebreaks]
    \frametitle{Rules of deduction}
    \scriptsize
    \begin{enumerate}
        \item \emph{Relfexivity}. For each $[t] \in T_{\Sigma,E}(\mathbf{X})$, 
            $$
            \infer[]{[t] \rightarrow [t']}{}
            $$
        \item \emph{Congruence}. For each $f \in \Sigma_n, n \in \mathbb{N}$,
            $$
            \infer[]{[f(t_1,\cdots,t_n)] \rightarrow [f(t_1',\cdots,t_n')]}{[t_1] \rightarrow [t_1']\ \cdots\ [t_n] \rightarrow [t_n']}            $$ 
        \item \emph{Replacement}. For each rule  
        \begin{align*}
            r&:[t(\overline{x})] \rightarrow [t'(\overline{x})]\ if \\
            &[u_1(\overline{x})] \rightarrow [v_1(\overline{x})] \wedge \cdots \wedge [u_n(\overline{x})] \rightarrow [v_n(\overline{x})]
        \end{align*}
        in $R$,
        \begin{prooftree}
            \alwaysNoLine
            \AxiomC{$[w_1] \rightarrow [w_1']$}
            \UnaryInfC{$[u_1(\overline{w}/ \overline{x})] \rightarrow [v_1(\overline{w}/ \overline{x})]$}
                \AxiomC{$\cdots$}
                \UnaryInfC{$\cdots$}
                    \AxiomC{$[w_n] \rightarrow [w_n']$}
                    \UnaryInfC{$[u_k(\overline{w}/ \overline{x})] \rightarrow [v_k(\overline{w}/ \overline{x})]$}
                \alwaysSingleLine
                \TrinaryInfC{$[t(\overline{w}/ \overline{x})] \rightarrow [t'(\overline{w}'/ \overline{x})]$}
        \end{prooftree}

        \item \emph{Transitivity}
        $$
        \infer[]{[t_1] \rightarrow [t_3]}{[t_1] \rightarrow [t_2] \quad [t_2] \rightarrow [t_3]} 
        $$
        \item \emph{Unconditional replacement}. For each 
        $$ r: [t(x_1,\cdots,x_n)] \rightarrow [t'(x_1,\cdots,x_n)]$$
        in R, 
        $$
        \infer[]{[t(\overline{w} / \overline{x} )] \rightarrow [t'(\overline{w'} / \overline{x})]}{[w_1] \rightarrow [w_1'] \quad \cdots \quad [w_n] \rightarrow [w_n']}
        $$
    \end{enumerate}
\end{frame}
\begin{frame}
    \frametitle{Additional rules}
    \scriptsize
    \begin{enumerate}
        \setcounter{enumi}{5}
        \item \emph{Substitution}
        $$
        \infer[]
        {[t(w_1)/x_{i_1},\cdots,w_n/x_{i_n}] \rightarrow [t'(w_1')/x_{i_1},\cdots,w_n'/x_{i_n}]}
        {[t(x_{i_1},\cdots,x_{i_n})] \rightarrow [t'(x_{i_1},\cdots,x_{i_n})] \quad [w_1] \rightarrow [w_1'] \cdots [w_n] \rightarrow [w_n']} 
        $$
    \end{enumerate}
    
    Any sequent derivable by adding (6) to  (1)-(4) can be derived by using only (1)-(4)

    \pause 
    \bigskip
    \emph{Equational logic} can be obtained  from rewriting logic by adding the following rule 
    \begin{enumerate}
        \setcounter{enumi}{6}
        \item \emph{Simmetry}
        $$
        \infer[]{[t_2] \rightarrow [t_1]}{[t_1] \rightarrow [t_2]} 
        $$
    \end{enumerate}
    \pause 
    
    \bigskip 
    We can now give the definition of \emph{concurrent rewriting}
\end{frame}
\begin{frame}
    \frametitle{Concurrent rewriting}
    $\mathcal{R} = (\Sigma, E, L, R)$
    \small
    
    \pause
    \medskip
    A $(\Sigma, E)$ sequent $[t] \rightarrow [t']$ is called:\begin{itemize}
        \item a \emph{0-step concurrent $\mathcal{R}$-rewrite} iff it can be derived from $\mathcal{R}$ by finite application 
        of rules (1) and (2)
        \pause
        \item a \emph{one-step concurrent $\mathcal{R}$-rewrite} iff it can be derived from $\mathcal{R}$
        by finite applications of rules (1)-(3), with at least one application of (3)
        \pause
        \item a \emph{concurrent $\mathcal{R}$-rewrite} iff it can be derived from $\mathcal{R}$ by finite applications of rules (1)-(4)
    \end{itemize}
\end{frame}
\begin{frame}
    $\mathcal{R} = (\Sigma, E, L, R)$
    \small
    \begin{block}{Lemma}
        For each concurrent $\mathcal{R}$-rewrite $[t] \rightarrow [t']$
        either $[t] = [t']$ or there is a $n  \in \mathbb{N} $ and a chain  of one step (concurrent) rewrites 
        $$
        \underbrace{[t] \rightarrow [t_1] \rightarrow \cdots \rightarrow [t_n] \rightarrow [t'] \onslide<2->}_{step\ seqeunce}
        $$ 
    \end{block}

    \onslide<3->{
    \medskip
    $\mathcal{R}$ is \emph{terminating} if there is no infinite chain of one step rewrites 

    \medskip
    $[t']$ is an $\mathcal{R}-normal\ form$ of $[t]$ if $[t] \rightarrow [t']$ is an 
    $\mathcal{R}$-rewrite and there is no $[t'] \rightarrow [t'']$ one-step  $\mathcal{R}$-rewrite
    }

    \onslide<4->{
    
    \medskip
    $\mathcal{R}$ is \emph{Church-Rosser} or \emph{confluent} if
    \begin{figure}
        \includegraphics[scale=0.2]{img/churchrosser.png}
    \end{figure}
    }
\end{frame}
\begin{frame}
    \frametitle{Reflection}

    Rewriting logic is \textbf{reflective}.

    \pause 
    \bigskip 
    There is a finitely presented rewrite theory $\mathbf{U}$ such that, for 
        any finitely presented rewrite theory $\mathbf{T}$ (including $\mathbf{U}$ itself) we have 
        the following equivalence 
        $$
        T \vdash [t] \rightarrow [t'] \Longleftrightarrow U \vdash  \langle \overline{T},\overline{[t]} \rangle  \rightarrow \langle \overline{T},\overline{[t']} \rangle
        $$ 

    \pause 
    This property is fundamental for the applications of RL, as we will see in Maude.
\end{frame}
\section{Semantic model}
\begin{frame}
    \begin{block}{What we have}
    $ R = (\Sigma, E, L, R)$

    \emph{Static description} of what a system can do 
        
    \end{block}
    
    \pause

    \begin{block}{What we want}
        \emph{Computational models} of the system behaviour (the \emph{meaning of the theory})
    \end{block}

    \pause

    \begin{block}{Idea}
        Take advantage of the correspondence between  \emph{deductions} in rewriting logic 
        and \emph{concurrent computations}
    \end{block}
\end{frame}
\begin{frame}
    \frametitle{The model }
    $
    R = (\Sigma, E, L, R)
    $

    \pause 
    \bigskip
    We seek a \textcolor{red}{category} $\mathcal{T_R(X)}$:\begin{itemize}
        \item Objects: \textcolor{blue}{$[t]_E$}
        \item Arrows: \textcolor{blue}{$[t_1]_E \xrightarrow{\pi} [t_2]_E$}
    \end{itemize}

    \pause 
    \bigskip
    \emph{Generator rules}: obtained by the rules of deduction (1)-(4) by decorating 
    the sequents with appropriate proof terms
\end{frame}
\begin{frame}
    \frametitle{Rules of generation}
    \scriptsize 
    \begin{enumerate}
        \item \emph{Identities.} For each $[t] \in T_{\Sigma, E}(\mathbb{X})$,
        $$
        \infer[]{[t]: [t] \rightarrow [t]}{}
        $$

        \item $\Sigma-structure$. For each $f \in \Sigma_n, n \in \mathbb{N}$,
        $$
        \infer[]
        {f(\alpha_1, \cdots, \alpha_n): [f(t_1, \cdots, t_n)] \rightarrow [f(t_1', \cdots, t_n')]}
        {\alpha_1: [t_1]}
        $$

        \item \emph{Replacement.} For each rewrite rule 
        \begin{align*}
        r:&[t(\overline{x})] \rightarrow [t'(\overline{x})]\ if \\ 
        &[u_1(\overline{x})] \rightarrow [v_1(\overline{x})] \wedge \cdots \wedge [u_k(\overline{x})] \rightarrow [v_k(\overline{x})] 
        \end{align*}
        in $\mathbb{R}$,
        \begin{prooftree}
            \alwaysNoLine
            \AxiomC{$\alpha_1 : [w_1] \rightarrow [w_1']$}
            \UnaryInfC{$\beta_1 : [u_1(\overline{w}/ \overline{x})] \rightarrow [v_1(\overline{w}/ \overline{x})]$}
                \AxiomC{$\cdots$}
                \UnaryInfC{$\cdots$}
                    \AxiomC{$\alpha_n : [w_n] \rightarrow [w_n']$}
                    \UnaryInfC{$\beta_k : [u_k(\overline{w}/ \overline{x})] \rightarrow [v_k(\overline{w}/ \overline{x})]$}
                \alwaysSingleLine
                \TrinaryInfC{$r(\overline{\alpha}^k,\overline{\beta}^k)[t(\overline{w}/ \overline{x})] \rightarrow [t'(\overline{w}'/ \overline{x})]$}
        \end{prooftree}

        \item \emph{Composition}
        $$
        \infer[]{\alpha;\beta : [t_1] \rightarrow [t_3]}{\alpha : [t_1] \rightarrow [t_2] \quad \beta : [t_2] \rightarrow [t_3]} 
        $$
    \end{enumerate}
\end{frame}
\begin{frame}
    For equational logic we can define a similar category $\mathcal{T_R}^{\leftrightarrow}(X)$ ( a \emph{groupoid}) by using 
    the rule of simmetry to generate additional terms 
    
    \bigskip 
    {
    \scriptsize
    \begin{enumerate}
        \setcounter{enumi}{4}
        \item  \emph{Inversion}. 
        $$
        \infer[]{\alpha^{-1} : [t_2] \rightarrow [t_1]}{\alpha : [t_1] \rightarrow [t_2]}
        $$
    \end{enumerate}
    }

    \bigskip
    \pause 
    \textbf{Note:}

    Ambiguity problems, which may arise when  the same label \emph{r} appears in two different rules of R are assumed 
    to be resolved by disambiguating \emph{r}  in the proof term $r(\overline{\alpha},\overline{\beta})$
\end{frame}
\begin{frame}
    \frametitle{$\mathcal{P_R}(X)$}
\end{frame}
\section{Maude}
\begin{frame}
    \frametitle{What is Maude}
    \textbf{Maude}
    \begin{itemize}
        \pause
        \item Declarative programming languaged based on rewriting logic 
        \begin{itemize}
            \item Built by SRI international and University of Illinois
            \item Includes membership equational logic as a sublanguage based on OBJ3 
        \end{itemize}
        \pause
        \item Modelling of distributed systems 
        \pause 
        \item  Explicit state analysis 
        \begin{itemize}
            \item Simulation by rewriting 
            \item reachability analysis 
            \item LTL and LTLR model checking 
        \end{itemize}
        \pause 
        \item Unification 
        \item SMT solver
    \end{itemize}
\end{frame}
\begin{frame}{Outline}
    \tableofcontents[currentsection, currentsubsection,hideothersubsections]
\end{frame}
\begin{frame}[fragile]
    \frametitle{Functional Modules}
    \begin{lstlisting}[language=maude]
            fmod NAT-ADD is
                sort Nat .
             op 0 : -> Nat [ctor] .
             op s_ : Nat -> Nat  .
             op _+_ : Nat Nat -> Nat [assoc comm id: 0] .
             vars M N : Nat . --- This is a comment
             eq s N + s M = s s (N + M) .
            endfm

Maude> in nat-add.maude 

Maude> red s(s(0)) + s(0) .
result Nat: s s s 0

    \end{lstlisting}
\end{frame}
    \begin{frame}[fragile]
        \frametitle{Including modules}
        \begin{lstlisting}[language=maude]
            fmod NAT-LIST-CONSTR is
                protecting NAT-ADD .
                sort List .
             op nil : -> List [ctor] .
             op _ _ : List Nat -> List [ctor] .
             endfm
             *** "1 2 3" -> nil s(0) s(s(0)) s(s(s(0))) ***
        \end{lstlisting}
        
    \end{frame}


\begin{frame}[fragile]
    \frametitle{System modules}
    \scriptsize
    \begin{columns}
        \begin{column}{.5\textwidth}
            
            \begin{lstlisting}[language=maude]
 fmod VENDING-MACHINE-SIGNATURE is
    sorts Coin Item Marking .
    subsorts Coin Item < Marking .
 op __ : Marking Marking ->
    Marking [assoc comm id: null] .
 op null : -> Marking .
 op $ : -> Coin [format (r! o)] .
 op q : -> Coin [format (r! o)] .
 op a : -> Item [format (b! o)] .
 op c : -> Item [format (b! o)] .
endfm
            \end{lstlisting}
        \end{column}
        \begin{column}{.5\textwidth}
            \begin{lstlisting}[language=maude]
        load vending-machine-signature.maude
        mod VENDING-MACHINE is
            including VENDING-MACHINE-SIGNATURE .
            var M : Marking .
         rl [add-q] : M => M q .
         rl [add-$] : M => M $ .
         rl [buy-c] : $ => c .
         rl [buy-a] : $ => a q .
         rl [change] : q q q q => $ .
         endm
    \end{lstlisting}
        \end{column}
    \end{columns}
   \begin{lstlisting}[language=maude]
Maude>  rew [3] $ $ q q .        result Marking: $ $ $ q q q q
    
        frew[2] $ $ q q .  result (sort not calculated): ($ q) ($ $) q q                 
        
        search [4, 10] $ q q q =>+ a c c M:Marking 
            such that M:Marking =/= null .
        
        Solution 1 (state 108) M --> q q q q 
            ...
    \end{lstlisting} 
\end{frame}

\begin{frame}[fragile]
    \frametitle{Model checking}
    \scriptsize
    \begin{columns}
        \begin{column}{.6\textwidth}
            
            \begin{lstlisting}[language=maude]
mod MUTEX is
    sorts Name Mode Proc Token Conf .
    subsorts Token Proc < Conf .
 op __ : Conf Conf -> 
    Conf [ctor assoc comm id: none] .
 ops a b : -> Name [ctor] .
 op none : -> Conf [ctor] .
 op [_,_] : Name Mode -> Proc [ctor] .
 ops wait critical : -> Mode [ctor] .
 ops * $ : -> Token [ctor] .
 rl [a-enter] : $ [a, wait] => [a, critical] .
 rl [b-enter] : * [b, wait] => [b, critical] .
 rl [a-exit] : [a, critical] => [a, wait] * .
 rl [b-exit] : [b, critical] => [b, wait] $ .
endm
            \end{lstlisting}
        \end{column}
        \begin{column}{.4\textwidth}
            \begin{lstlisting}[language=maude]
    load mutex.maude
    load model-checker.maude
    
    mod MUTEX-PREDS is
        protecting MUTEX .
        including SATISFACTION .
        subsort Conf < State .
      op crit : Name -> Prop .
      op wait : Name -> Prop .
      var N : Name .
      var C : Conf .
      var P : Prop .
      eq [N, critical] C |= 
              crit(N) = true .
      eq [N, wait] C |=
              wait(N) = true .
      eq C |= P = false [owise] .
    endm
            \end{lstlisting}
        \end{column}
    \end{columns}
    
\end{frame}
\begin{frame}[fragile]
    \scriptsize
    \frametitle{Model checking}
    \begin{lstlisting}[language=maude]
         load mutex-preds.maude
        mod MUTEX-CHECK is
            protecting MUTEX-PREDS .
            including MODEL-CHECKER .
            including LTL-SIMPLIFIER .
         ops initial1 initial2 : -> Conf .
         eq initial1 = $ [a, wait] [b, wait] .
         eq initial2 = * [a, wait] [b, wait] .
        endm
***(
Maude> red modelCheck(initial1, [] ~(crit(a) /\ crit(b))) .
reduce in MUTEX-CHECK : modelCheck(initial1, []~ (crit(a) /\ crit(b))) .
rewrites: 22 in 10ms cpu (434ms real) (2200 rewrites/second)
result Bool: true

Maude> red modelCheck(initial2, [] ~(crit(a) /\ crit(b))) .
reduce in MUTEX-CHECK : modelCheck(initial2, []~ (crit(a) /\ crit(b))) .
rewrites: 22 in 0ms cpu (0ms real) (~ rewrites/second)
result Bool: true
)***
    \end{lstlisting}
\end{frame}
\begin{frame}
    \frametitle{The meta level }
    Maude exploits the reflective nature of rewriting logic. Every maude \emph{module} \textbf{$M$} can be represented  as 
    a \emph{term} \textbf{$\overline{M}$} of \emph{Sort} \textbf{Module}. 

    \bigskip
    \pause 
    Fundamental for developing tools in Maude. \emph{Full Maude}, Real Time Maude and all the 
    other extensions make use of this property.
    
    \pause
    \bigskip 
    Maude efficiently implements the universal theory $\mathcal{U}$ in the META-* modules

\end{frame}
\begin{frame}[fragile]
    \scriptsize
    \frametitle{Objects in Full Maude}
    \begin{lstlisting}[language=maude]
    (omod ACCNT is 
        protecting QID .
        protecting MACHINE-INT .
        subsort Qid < Oid .
        class Accnt | bal : MachineInt .  
        
        msgs credit debit : Oid MachineInt -> Msg .  
        msg transfer_from_to_ : MachineInt Oid Oid -> Msg .  

        vars A B : Oid . 
        vars M N N' : MachineInt .  

     rl [credit] : credit(A, M) < A : Accnt | bal : N >
       => < A : Accnt | bal : (N + M) > .  
     crl [debit] : debit(A, M) < A : Accnt | bal : N >
       => < A : Accnt | bal : (N - M) >
          if N > M .  
     crl [transfer] : (transfer M from A to B)
       < A : Accnt | bal : N > < B : Accnt | bal : N' > 
       => < A : Accnt | bal : (N - M) > 
          < B : Accnt | bal : (N' + M) >
          if N > M . 
    endom)
    \end{lstlisting}
\end{frame}
\subsection{Maude by example}
\section{Applications}
\begin{frame}
    \frametitle{Applications}
    \begin{itemize}
        \item Formalization of programming languages 
        \begin{itemize}
            \item C
            \item Java, JVM
            \item Scheme
            \item K framework
            \item ...
        \end{itemize}
        \item Security: uncovering unknown attacks on web browsers 
        \item Logical framework 
        \begin{itemize}
            \item Barendregt's lambda cube 
            \item Linear logic 
            \item Modal logic
            \item ...
        \end{itemize}
        \item Biology : Pathway logic 
        \item Cloud transactions: \textcolor{red}{Google's Megastore}, Cassandra,...
    \end{itemize}

    For reference:

    http://maude.cs.illinois.edu/w/index.php/Applications
\end{frame}
\begin{frame}
    \frametitle{Google Megastore}
    \begin{itemize}
        \item Google's replicated data store 
        \item Billions  of read/write daily transactions 
        \item Adds (limited) support for transactions  in distributed data stores   
    \end{itemize}
    \begin{figure}
        \includegraphics[width=\textwidth]{img/megastore.png}
    \end{figure}
\end{frame}
\begin{frame}
    \begin{itemize}
        \item Data divided into \textbf{entity groups} 
        \item \textbf{Replicated transaction log}  for each group
        \item Two phase commits with a paxos-based protocol 
    \end{itemize}
    \begin{figure}
        \includegraphics[scale=0.2]{img/paxos.png}
    \end{figure}
\end{frame}
\begin{frame}
    \frametitle{Issues}
    \begin{itemize}
        \item Original overview definition very informal, \textbf{really complex system}
        \item No consistency guarantee if a transaction reads multiple entity groups
    \end{itemize}
\end{frame}
\begin{frame}
    \frametitle{MegaStore CGC}

    Work by  Grov and $\ddot{\text{O}}$lveczky 
    \begin{itemize}
        \item Formalized Google MegaStore in Real-Time Maude
        \begin{itemize}
            \item 56 rewrite rules 
            \item Use  of simulation and model checking to discover bugs during development
        \end{itemize} 
        \item Introduced MegaStore CGC, an extension that provides consistency for transactions 
        accessing multiple entity groups 
    \end{itemize} 
    
\end{frame}
\begin{frame}
    \frametitle{Main ideas}

    \begin{itemize}
        \item A site participates in all updates involving the entity groups it replicates 
            \begin{itemize}
                \item Implicit ordering on these updates
                \item \textbf{Idea}: make the order \emph{explicit}
                \item Valida transactions on multiple entity groups before commit 
            \end{itemize}
            
        \bigskip
        \pause
        \item Formal test driven development 
            \begin{enumerate}
                \item Express requirements as LTL formulas
                \item Develop Real Time Maude model 
                \item Test model through simulation and model checking 
                \item Analyse failures and modify the model
            \end{enumerate}
    \end{itemize}
\end{frame}
\begin{frame}[fragile]
    \scriptsize
    \frametitle{MegaStore Maude fragments}
    \begin{lstlisting}[language=maude]
class Site | entityGroups : Configuration, localTransactions : Configuration,
            coordinator : EntGroupLogPosPairSet, egOrderings : OrderClassUpdates,
            awaitingOrder : EntGroupUpdateList .

class EntityGroup | entitiesState : EntitySet, transactionLog : LogEntryList,
                    replicas : EntityGroupReplicaSet, proposals : PaxosProposalSet,
                    pendingWrites : PendingWriteList .

class Transaction | operations : OperationList, status : TransStatus,
                    reads : EntitySet, readState : ReadStateSet,
                    writes : OperationList, paxosState : PaxosStateSet .
    \end{lstlisting}
\end{frame}
\begin{frame}[fragile]
    \scriptsize
    \begin{lstlisting}[language=maude]
crl [initiateCommit] :
    < SID' : Site |
    entityGroups EGROUPS,
    localTransactions : LOCALTRANS
    < TID : Transaction | operations : emptyOpList,
    writes : WRITEOPS, status : idle
    readState : RSTATE, paxosState : PSTATE > >
    =>
    < SID : Site |
    localTransactions : LOCALTRANS
    < TID : Transaction | paxosState : NEW-PAXOS-STATE,
    status : in-paxos > >
    ACC-LEADER-REQ-MSGS
if EIDSET := getEntityGroupIds(WRITEOPS) /\
    NEW-PAXOS-STATE := initiatePaxosState(EIDSET, TID, WRITEOPS,
    SID, RSTATE, EGROUPS)
/\ (createAcceptLeaderMessages(SID, NEW-PAXOS-STATE)) => ACC-LEADER-REQ-MSGS
    \end{lstlisting}

\end{frame}
\begin{frame}[fragile]
    \scriptsize 
    \begin{lstlisting}[language=maude]
crl [rcvAcceptAllReq] :
(msg acceptAllReq(TID, EG, (TID' LP SID OL), PROPNUM) from SENDER to THIS)
    < THIS : Site |
    entityGroups : EGROUPS
    < EG : EntityGroup | proposals : PROPSET, transactionLog : LEL > >
  =>
    < THIS : Site |
    entityGroups : EGROUPS
    < EG : EntityGroup |
    proposals : accepted(SENDER, (TID' LP SID OL), PROPNUM) ;
    removeProposal(LP, PROPSET) > >
    dly(acceptAllRsp(TID, EG, LP, PROPNUM) from THIS to SENDER), T)
if not (containsLPos(LP, LEL) or hasAcceptedForPosition(LP, PROPSET))
/\ T ; TS := possibleMessageDelay(THIS, SENDER) .       
    \end{lstlisting}
\end{frame}
\begin{frame}[fragile]
    \frametitle{LTL requirements}
    Desired Property: 
    \begin{lstlisting}[language=maude, basicstyle=\scriptsize]
    <> [] (allTransFinished /\ entityGroupsEqualOrInvalid
    /\ transLogsEqualOrInvalid /\ isSerializable)
    \end{lstlisting}

    \pause
    All replicas are equal Property:
    \begin{lstlisting}[language=maude, basicstyle=\scriptsize]
    op entityGroupsEqualOrInvalid : -> Prop [ctor] .
    
    ceq {< S1 : Site | coordinator : eglp(EG1, LP) ; EGLP,
                    entityGroups :
                    < EG1 : EntityGroup | entitiesState : ES1 > EGS1 >
        < S2 : Site | coordinator : eglp(EG1, LP) ; EGLP,
                    entityGroups :
                    < EG1 : EntityGroup | entitiesState : ES2 > EGS2 >
    REST} |= entityGroupsEqual = false if ES1 =/= ES2 .
    
    eq {SYSTEM} |= entityGroupsEqualOrInvalid = true [owise] .
    \end{lstlisting}
\end{frame}


\end{document}