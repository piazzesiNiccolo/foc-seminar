\documentclass{beamer}
\usepackage{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{stmaryrd}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{proof}
\usepackage{bussproofs}
\usepackage{listings}
\usepackage{amsmath}

\usetheme{Copenhagen}
\usefonttheme{professionalfonts}
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{headline}{}

\definecolor{delimiterColor}{HTML}{B65E47}
\definecolor{numberColor}{HTML}{FF0000}
\definecolor{commentColor}{HTML}{008000}
\definecolor{keyColor}{HTML}{002BFF}

\lstdefinelanguage{maude}
{
	breaklines=true,
	extendedchars=true,
	tabsize=2,
	frame=none,
	columns=fullflexible,
	showtabs=false,
	showstringspaces=false,
	showspaces=false,
	showstringspaces=false,
	identifierstyle={\ttfamily},
	keywordstyle={\color{keyColor}},
	ndkeywordstyle={\color{keyColor}},
	stringstyle={\color{delimiterColor}},
	commentstyle={\color{commentColor}},
	ndkeywords={Int, Bool, String},
	keywords={in, load, pr, protecting, sort, sorts, op, ops, var, vars,eq, cq, ceq,endfm, fmod, is, mod, endm, load, =, ==, =/=, euler, discreteswitch, nonaccurate, mp, rk4, accurate, init, exp, abs, true, false, nil, ctor, PhysicalEntityStar, PhysicalInteraction, PhysicalEntity, PhysicalEntityPC1, FlowSource, SysMan, effortDyn, flowDyn, Object, Oid, assoc, id, DataCollector, Rat, NzNat, frac, trunc, if, else, class, load, homod, endhom, eof, var, vars, eq, op, ops, pr, inc, protecting, including, ceq, is, tomod, endtom, msg, rl, crl, trew, hfind, hsearch, tsearch, hmc, hrew, time, earliest, such, that, subclass, Prop, omod, sort, subsort, not, endom, fi, msgs, fmod, endfm, hfrew, then, mod, and, or, endm, endtm, in, out, set, trace, exclude, loop, show, using, stepsize, tick, Oid, Nat, Float, Configuration, String, NzNat},
	morecomment={[l]{***}},
	morecomment={[l]{---}},
}
\AtBeginSection[ ]
{
\begin{frame}{Outline}
    \tableofcontents[currentsection, hideallsubsections]
\end{frame}
}
\title{Conditional Rewriting Logic \& Maude}
\author{Niccolò Piazzesi}
\institute{
    Università degli studi di Pisa
}
\titlegraphic{\includegraphics[width=2cm]{img/logo.png}}
\begin{document}

\frame{\titlepage}

\begin{frame}{Outline}
    \tableofcontents[hideallsubsections]
\end{frame}
\section{Introduction and main concepts}
\begin{frame}
    \frametitle{What is a concurrent system?}
    Modelling concurrent system is one of the most studied problems in Computer Science

    \bigskip
    \pause
    Many proposed answers:\begin{itemize}
        \item Petri Nets 
        \item CCS
        \item CSP 
        \item Actors
        \item $\cdots$
    \end{itemize}
\end{frame}
\begin{frame}
    \frametitle{The need for unification}
    \pause
        \begin{block}{External fragmentation}
            Hard to relate different approaches, each with their own concepts, models and issues
        \end{block}
    \pause 
    \begin{block}{Internal fragmentation}
        Sometimes, fragmentation appears also within a specific approach (e.g. how can we unify operational and denotational semantics of CCS?)
    \end{block}
    \pause
    \begin{block}{Concurrency in other areas}
        A related problem is the integration of concurrency with other paradigms ( OO, Functional, ...)
        without using complex \emph{ad hoc} solutions.
    \end{block}
\end{frame}

\begin{frame}
    
    Rewriting logic aim to resolve these issues with a two sides approach
    \pause
    \begin{block}{Computational side}
        Computationally, rewriting logic is a \emph{semantic framework} where many different 
        models and languages can be represented and executed as \textbf{rewrite theories}. 
    \end{block}
    \pause
    \begin{block}{Logical side}
        Rewriting logic  is also a \emph{logical framework}, a model within which 
        many other logics and deduction procedures  can be modeled and reasoned about.        
    \end{block}
\end{frame}
\section{Foundations}
\begin{frame}
    \frametitle{A logic of action}
    The rules of rewriting logic resemble those of equational logic, but the meaning is very different

    \begin{center}
        \textbf{Rewriting logic is a logic to reason about \emph{change} in a concurrent system, \emph{not about equality}}
    \end{center}
\pause 

\bigskip 
Rewriting logic identifies \textbf{concurrent rewriting} with \textbf{deduction}
\end{frame}

\begin{frame}
    \frametitle{Rewrite Theory}
    \begin{center}
        \resizebox{3cm}{!}{$(\Sigma, E, L, R)$}
    \end{center}
    
    \bigskip
    \begin{itemize}
        \pause
        \item $\Sigma$: ranked alphabet of function symbols
        \pause
        \item E: set  of $\Sigma$-equations 
        \pause
        \item L: set of \emph{labels}
        \pause
        \item R: set of pairs $R \subseteq L \times (T_{\Sigma, E}(\mathbf{X})^2)^+$
    \end{itemize}
    
    \pause
    \bigskip
    $T_{\Sigma,E}(\mathbf{X})$ denotes the $\Sigma-algebra$ of equivalence classes of $\Sigma-terms$ with variables in $\mathbf{X}$ modulo the equations E
    
    \medskip
    Elements of R are called \emph{rewrite rules}
\end{frame}
\begin{frame}
    \frametitle{Rewriting rules}
    A rewrite rule 
    \begin{center}
        $(r,([t],[t'])([u_1],[v_1])\cdots([u_k],[v_k]))$
    \end{center}
    is written as 
    $$
    r:[t] \rightarrow [t']\ if\ \underbrace{[u_1]\rightarrow[v_1] \wedge \cdots \wedge [u_k] \rightarrow [v_k] \pause}_{condition\ C}
    $$
    
    \bigskip
    \pause
    If a condition is empty, we have an \emph{unconditional rewrite rule} 
    $$
    r:[t] \rightarrow [t']
    $$
    

    If all the rules are unconditional , we have an \emph{unconditional rewrite theory}
\end{frame}
\begin{frame}

    An example: natural numbers with a nondeterministic choice operator 
    
    \pause
    \begin{itemize}
        \item $\Sigma = \{0,s\_,\_+\_,\_?\_\}$
        \pause
        \item $E = \{N + M = M + N\}$
        \pause
        \item R = 
            \vspace{-5mm}
            \begin{align*}
                &r1: N+0 \rightarrow N \\ 
                &r2: (s\ N) + (s\ M) \rightarrow s\ s\ (N + M) \\ 
                &r3: N ? M \rightarrow N \\ 
                &r4: N ? M \rightarrow M 
            \end{align*}
    \end{itemize}
\end{frame}
\begin{frame}
    \frametitle{Sequent entailment}
    \begin{center}
        \resizebox{3cm}{!}{$\mathcal{R} \vdash [t] \rightarrow [t']$}
    \end{center}

    \pause 
    \vspace{2cm}
    A rewrite theory $\mathcal{R}$ \emph{entails} a \emph{sequent}
    $ [t] \rightarrow [t']$ \emph{iff} $[t] \rightarrow [t']$ can be obtained 
    by finite application of \emph{rules of deduction}.
\end{frame}
\begin{frame}[allowframebreaks]
    \frametitle{Rules of deduction}
    \scriptsize
    \begin{enumerate}
        \item \emph{Relfexivity}. For each $[t] \in T_{\Sigma,E}(\mathbf{X})$, 
            $$
            \infer[]{[t] \rightarrow [t']}{}
            $$
        \item \emph{Congruence}. For each $f \in \Sigma_n, n \in \mathbb{N}$,
            $$
            \infer[]{[f(t_1,\cdots,t_n)] \rightarrow [f(t_1',\cdots,t_n')]}{[t_1] \rightarrow [t_1']\ \cdots\ [t_n] \rightarrow [t_n']}            $$ 
        \item \emph{Replacement}. For each rule  
        \begin{align*}
            r&:[t(\overline{x})] \rightarrow [t'(\overline{x})]\ if \\
            &[u_1(\overline{x})] \rightarrow [v_1(\overline{x})] \wedge \cdots \wedge [u_n(\overline{x})] \rightarrow [v_n(\overline{x})]
        \end{align*}
        in $R$,
        \begin{prooftree}
            \alwaysNoLine
            \AxiomC{$[w_1] \rightarrow [w_1']$}
            \UnaryInfC{$[u_1(\overline{w}/ \overline{x})] \rightarrow [v_1(\overline{w}/ \overline{x})]$}
                \AxiomC{$\cdots$}
                \UnaryInfC{$\cdots$}
                    \AxiomC{$[w_n] \rightarrow [w_n']$}
                    \UnaryInfC{$[u_k(\overline{w}/ \overline{x})] \rightarrow [v_k(\overline{w}/ \overline{x})]$}
                \alwaysSingleLine
                \TrinaryInfC{$[t(\overline{w}/ \overline{x})] \rightarrow [t'(\overline{w'}/ \overline{x})]$}
        \end{prooftree}

        \item \emph{Transitivity}
        $$
        \infer[]{[t_1] \rightarrow [t_3]}{[t_1] \rightarrow [t_2] \quad [t_2] \rightarrow [t_3]} 
        $$
        \item \emph{Unconditional replacement}. For each 
        $$ r: [t(x_1,\cdots,x_n)] \rightarrow [t'(x_1,\cdots,x_n)]$$
        in R, 
        $$
        \infer[]{[t(\overline{w} / \overline{x} )] \rightarrow [t'(\overline{w'} / \overline{x})]}{[w_1] \rightarrow [w_1'] \quad \cdots \quad [w_n] \rightarrow [w_n']}
        $$
    \end{enumerate}
\end{frame}
\begin{frame}
    \frametitle{Additional rules}
    \scriptsize
    \begin{enumerate}
        \setcounter{enumi}{5}
        \item \emph{Substitution}
        $$
        \infer[]
        {[t(w_1)/x_{i_1},\cdots,w_n/x_{i_n}] \rightarrow [t'(w_1')/x_{i_1},\cdots,w_n'/x_{i_n}]}
        {[t(x_{i_1},\cdots,x_{i_n})] \rightarrow [t'(x_{i_1},\cdots,x_{i_n})] \quad [w_1] \rightarrow [w_1'] \cdots [w_n] \rightarrow [w_n']} 
        $$
    \end{enumerate}
    
    Any sequent derivable by adding (6) to  (1)-(4) can be derived by using only (1)-(4)

    \pause 
    \bigskip
    \emph{Equational logic} can be obtained  from rewriting logic by adding the following rule 
    \begin{enumerate}
        \setcounter{enumi}{6}
        \item \emph{Simmetry}
        $$
        \infer[]{[t_2] \rightarrow [t_1]}{[t_1] \rightarrow [t_2]} 
        $$
    \end{enumerate}
    \pause 
    
    \bigskip 
    We can now give the definition of \emph{concurrent rewriting}
\end{frame}
\begin{frame}
    \frametitle{Concurrent rewriting}
    $\mathcal{R} = (\Sigma, E, L, R)$
    \small
    
    \pause
    \medskip
    A $(\Sigma, E)$ sequent $[t] \rightarrow [t']$ is called:\begin{itemize}
        \item a \emph{0-step concurrent $\mathcal{R}$-rewrite} iff it can be derived from $\mathcal{R}$ by finite application 
        of rules (1) and (2)
        \pause
        \item a \emph{one-step concurrent $\mathcal{R}$-rewrite} iff it can be derived from $\mathcal{R}$
        by finite applications of rules (1)-(3), with at least one application of (3)
        \pause
        \item a \emph{concurrent $\mathcal{R}$-rewrite} iff it can be derived from $\mathcal{R}$ by finite applications of rules (1)-(4)
    \end{itemize}
\end{frame}
\begin{frame}
    $\mathcal{R} = (\Sigma, E, L, R)$
    \small
    \begin{block}{Lemma}
        For each concurrent $\mathcal{R}$-rewrite $[t] \rightarrow [t']$
        either $[t] = [t']$ or there is a $n  \in \mathbb{N} $ and a chain  of one step (concurrent) rewrites 
        $$
        \underbrace{[t] \rightarrow [t_1] \rightarrow \cdots \rightarrow [t_n] \rightarrow [t'] \onslide<2->}_{step\ seqeunce}
        $$ 
    \end{block}

    \onslide<3->{
    \medskip
    $\mathcal{R}$ is \emph{terminating} if there is no infinite chain of one step rewrites 

    \medskip
    $[t']$ is an $\mathcal{R}-normal\ form$ of $[t]$ if $[t] \rightarrow [t']$ is an 
    $\mathcal{R}$-rewrite and there is no $[t'] \rightarrow [t'']$ one-step  $\mathcal{R}$-rewrite
    }

    \onslide<4->{
    
    \medskip
    $\mathcal{R}$ is \emph{Church-Rosser} or \emph{confluent} if
    \begin{figure}
        \includegraphics[scale=0.2]{img/churchrosser.png}
    \end{figure}
    }
\end{frame}
\section{Semantic model}
\section{Maude}
\section{Applications}
\end{document}